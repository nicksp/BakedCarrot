<?php
/**
 * BakedCarrot ORM cache manager
 * 
 * @package BakedCarrot
 * @subpackage Db
 */
class OrmCache
{
	/**
	 * Prefix of data keys in cache
	 */
	const DATA_PREFIX = 'bc_orm_data_';

	/**
	 * Prefix of field that holds exists cache keys
	 */
	const KEYS_PREFIX = 'bc_orm_keys_';

	private static $cache_driver = null;
	private static $internal_cache_data = null;
	private static $internal_cache_tables = null;


	/**
	 * Private constructor to prevent this class from creating directly
	 */
	private function __construct()
	{
	}


	/**
	 * Initialize class
	 * @static
	 * @param Cache $cache cache module
	 */
	public static function create(Cache $cache)
	{
		self::$cache_driver = $cache;
	}


	/**
	 * Indicates that class really initialized
	 *
	 * @static
	 * @return bool
	 */
	public static function initialized()
	{
		return (bool)self::$cache_driver;
	}


	/**
	 * Puts the query in the cache
	 *
	 * @static
	 * @param string $key key generated by getKey
	 * @param string $table name of the table
	 * @param mixed $data query results that should be cached
	 * @return bool
	 * @throws BakedCarrotOrmException
	 */
	public static function cacheQuery($key, $table, $data)
	{
		if(!self::$cache_driver) {
			return false;
		}
		
		$table = trim($table);
		
		if(!$table) {
			throw new BakedCarrotOrmException('Cannot cache query without table name. Cache key: ' . $key);
		}
	
		self::$cache_driver->set($key, $data);
		
		// store the keys for table
		$tables = explode(',', $table);

		foreach($tables as $table) {
			$table_key = self::KEYS_PREFIX . strtolower(trim($table));
			$keys = self::$cache_driver->get($table_key);
		
			if(!is_array($keys) || !in_array($key, $keys)) {
				$keys[] = $key;
			}
			
			self::$cache_driver->set($table_key, $keys);
		}
	}


	/**
	 * Returns the result of the cached query
	 *
	 * @static
	 * @param $key
	 * @return bool
	 */
	public static function getCachedQuery($key)
	{
		if(!self::$cache_driver) {
			return false;
		}
	
		$result = self::$cache_driver->get($key);
		
		return $result === null ? false : $result;
	}


	/**
	 * Clears all cached results for given table
	 *
	 * @static
	 * @param $table
	 * @return bool
	 */
	public static function clearCacheForTable($table)
	{
		if(isset(self::$internal_cache_tables[$table])) {
			foreach(self::$internal_cache_tables[$table] as $key_to_wipe) {
				unset(self::$internal_cache_data[$key_to_wipe]);
			}
			
			unset(self::$internal_cache_tables[$table]);
		}
	
		if(!self::$cache_driver) {
			return false;
		}
		
		$tables = explode(',', $table);
		foreach($tables as $table) {
			$table_key = self::KEYS_PREFIX . strtolower(trim($table));
			$keys = self::$cache_driver->get($table_key);
			
			if(is_array($keys)) {
				foreach($keys as $key) {
					self::$cache_driver->delete($key);
				}
			}
			
			self::$cache_driver->delete($table_key);
		}
	}


	/**
	 * Generate key from SQL string and query values
	 *
	 * @static
	 * @param $sql
	 * @param $values
	 * @return string
	 */
	public static function genKey($sql, $values)
	{
		$values_crc = crc32(serialize($values));
		$sql_crc = crc32($sql);
		
		return self::DATA_PREFIX . $sql_crc . '_' . $values_crc;
	}


	/**
	 * Returns results from internal cache (session cache)
	 *
	 * @static
	 * @param $key
	 * @return bool
	 */
	public static function getFromInternalCache($key)
	{
		if(isset(self::$internal_cache_data[$key])) {
			return self::$internal_cache_data[$key];
		}
	
		return false;
	}


	/**
	 * Stores the data in the internal cache
	 *
	 * @static
	 * @param $key
	 * @param $table
	 * @param $data
	 */
	public static function storeInternal($key, $table, $data)
	{
		self::$internal_cache_tables[$table][] = $key;
		self::$internal_cache_data[$key] = $data;
	}
}

